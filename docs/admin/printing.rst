.. _lino.admin.printing:

===================================
Introduction to printable documents
===================================

.. How to test only this document:

     $ python doctest docs/admin/printing.rst

   Initialize doctest:

    >>> from lino import startup
    >>> startup('lino_book.projects.docs.settings.doctests')
    >>> from lino.api.shell import *
    >>> from lino.api.doctest import *
    

In a web application that runs on a public server, "printing" rather
consists in producing a printable document and then show it in the
client's browser.

Lino comes with a selection of ready-to-use mechanisms for generating
**printable documents** using different types of **templates**.  This
section introduces the basic concepts.

.. currentmodule:: lino.modlib.printing

What is a printable document?
=============================

A **printable document** is a file generated by Lino and delivered to
the end-user who will view it in their browser (or some external
application if their browser is configured accordingly) and possibly
print them out on their printer.

Printable documents are typically either in `.pdf` format (for
*read-only* files) or one of `.odt`, `.doc` or `.rtf` (for *editable*
files). Sites which offer *editable* printables to their users might
also use :ref:`davlink` so that the users don't need to save these
files on their client machines.

End-users see a printable document by invoking the :attr:`do_print
<Printable.do_print>` action of a *printable database object* (see
also the :class:`Printable` model mixin).

Lino applications can decide to use printable documents on other
places, e.g.  attach them to an email or send them directly from the
application server to a printer in a local area network.


What is a print template?
=========================

A **print template** is a file that serves as *master document* for
building a *printable document*.  Lino processes the template using a
given *build method*, inserting data from the database and producing
the printable document as a new file stored in a *cache* directory.

Print templates are part of your site configuration (see
:doc:`config_dirs`).  The easiest way to edit and manage your
templates is to make your server's *local configuration directory*
accessible to your desktop computer and to use some file manager of
your choice.

Templates are either **WYSIWYG** (`.odt`, `.rtf`) or **Markup**
(`.html`, `.tex`), depending on the used build method.


The print action
================

Here is what happens when a user invokes the :attr:`do_print
<Printable.do_print>` action of a printable object:

- Lino **generates** ("builds") the printable document on the server.
  For cached printables (see :class:`CachedPrintable`), Lino may skip
  this step if that document had been generated earlier.

- Lino **delivers** the document to the user. 


Build methods
=============

Lino comes with a list of "build methods".  You can imagine a build
method as a kind of "driver" who generates ("builds") printable
documents from a template.

>>> rt.show(printing.BuildMethods)
======= ======= ==================
 value   name    text
------- ------- ------------------
 latex   latex   LatexBuildMethod
 pisa    pisa    PisaBuildMethod
 rtf     rtf     RtfBuildMethod
 xml     xml     XmlBuildMethod
======= ======= ==================
<BLANKLINE>




Template engines
================

This section is partly obsolete.

A `template engine <http://en.wikipedia.org/wiki/Template_engine_(web)>`_ 
is responsible for replacing *template commands* by their result.
The template engine determines the syntax for specifying template 
commands when designing templates.

- :doc:`appy_templates`

- :class:`PisaBuildMethod` and :class:`LatexBuildMethod` use 
  `Django's template engine
  <http://docs.djangoproject.com/en/1.11/topics/templates/>`_ whose 
  template commands look for example like 
  ``{% if instance.has_family %}yes{% else %}no{% endif %}``
  or
  ``My name is {{ instance.name }}.``.

- :class:`RtfBuildMethod` uses :term:`pyratemp` as template engine 
  whose template commands looks like ``@!instance.name!@``.
  We cannot use Django's template engine because 
  both use curly braces as command delimiters.
  
  This build method has a flaw: I did not find a way to 
  "protect" the template commands in your RTF files from being formatted by Word.
  

Markup versus WYSIWYG
=====================

Template collections that use some markup language are usually less
redundant because you can design your collection intelligently by
using template inheritance.

On the other hand, maintaining a collection of markup templates
requires a relatively skilled person because the maintainer must know
two "languages": the template engine's syntax and the markup syntax.

WYSIWYG templates (OpenOffice or Word) increase the probability that
an end-user is able to maintain the template collection because
there's only on language to learn (the template engine's syntax)



Post-processing
===============

Some print methods need post-processing: the result of parsing must be
run through another software in order to turn into a usable format.
Post-processing creates dependencies to other software and has of
course influence on runtime performance.

   
Weblinks
========

.. glossary::

  Pisa
    http://www.xhtml2pdf.com/
    HTML/CSS to PDF converter written in Python.
    See also :srcref:`/docs/blog/2010/1020`
    
  odtwriter
    http://www.rexx.com/~dkuhlman/odtwriter.html
    http://www.linuxbeacon.com/doku.php?id=articles:odfwriter
  
  pyratemp
    http://www.simple-is-better.org/template/pyratemp.html


